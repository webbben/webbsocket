{"version":3,"file":"index.js","sources":["../src/index.tsx"],"sourcesContent":["import React, { ReactNode, createContext, useContext, useEffect, useRef, useState } from \"react\";\n\ninterface WebSocketProviderProps {\n    children: ReactNode\n    /** JWT auth token to be sent to the server, if you'd like to authorize your websocket clients.\n     * \n     * If provided, will be sent as a message of type \"authorization\" after initial connection is established.\n     * The server should wait for this authorization message and verify the token (stored in the message \"content\") before\n     * trusting a websocket connection.\n     */\n    authToken?: string\n    /** Enables printing debug statements to the console; useful if you want to investigate issues with this websocket provider. \n     * \n     * Warnings and errors will be printed to the console regardless of this setting.\n     */\n    debug?: boolean\n    /**\n     * URL of the server/port/endpoint listening for this websocket connection, e.g. \"localhost:8080/ws/endpoint\".\n     * \n     * Note: do not include any protocols (http, https, ws, etc). We add the 'ws' protocol in ourselves.\n     */\n    serverURL: string\n    /**\n     * Determines if websocket will automatically attempt to reconnect if its connection closes, for any reason.\n     * Defaults to true.\n     */\n    autoReconnect?: boolean\n    /**\n     * The maximum number of attempts at automatic reconnection; only applicable if autoReconnect is set to true.\n     * Default is 5 attempts.\n     */\n    maxReconnectAttempts?: number\n    /**\n     * The timeout between each automatic reconnection attempt; only applicable if autoReconnect is set to true.\n     */\n    autoReconnectTimeout?: number\n\n}\ninterface WebSocketContextType {\n    /**\n     * Sends a message over websocket to your server.\n     * @param message a message object containing the information to send over websocket.\n     * * type property: meant to specify how the message should be handled on your server \n     * (i.e., is this message a chat message to another user, or an update notification to sync with other clients, etc.)\n     * * content property: meant to be the actual content of the message you want to send (the contents of a chat message, etc)\n     */\n    sendMessage: (message: WebsocketMessage) => void;\n    /**\n     * Registers a callback function to execute when a message is received; you can optionally filter which message types this callback responds to.\n     * @param callback a callback function for when the websocket connection receives a message from the server\n     * @param typeFilters optionally provide a list of types to filter messages based on - if the incoming message is one of these types, the message will be sent to the callback function.\n     */\n    handleMessage: (callback: (incomingMessage: WebsocketMessage) => void, typeFilters?: string[]) => () => void;\n    /**\n     * Whether the websocket connection is currently open; You can use this in useEffect dependency arrays to do things like setting message handler callback functions once the websocket connection is live.\n     */\n    connectionOpen: boolean;\n}\n\n/**\n * Basic properties of a message.\n */\nexport interface WebsocketMessage {\n    /** The type of the message - for identifying its purpose and for special handling */\n    type: string,\n    /** The content of the message - the actual data payload to be communicated, whether its a chat message or a general data update */\n    content: string,\n    /** Timestamp of when this message was sent - if not set, it will be filled in by the Websocket Provider */\n    timestamp?: number\n}\n\nconst WebSocketContext = createContext<WebSocketContextType | undefined>(undefined);\n\n/**\n * Sets up a websocket connnection and gives descendents access to it via the useWebSocket hook\n */\nexport const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ children, authToken, debug, serverURL, autoReconnect = true, maxReconnectAttempts = 5, autoReconnectTimeout = 5000 }) => {\n\n    const ws = useRef<WebSocket | null>(null);\n    const [connectionOpen, setConnectionOpen] = useState(false);\n    const reconnectAttempts = useRef<number>(0);\n    const messageQueue = useRef<WebsocketMessage[]>([]); // enqueue messages if they are unable to be sent\n\n    useEffect(() => {\n        const initializeWebsocket = () => {\n            ws.current = new WebSocket(`ws://${serverURL}`);\n\n            ws.current.addEventListener('open', (_event) => {\n                debugLogger('WebSocket: connection opened');\n                setConnectionOpen(true);\n                reconnectAttempts.current = 0;\n                // send auth info\n                if (authToken) {\n                    const message: WebsocketMessage = {\n                        type: \"authorization\",\n                        content: authToken,\n                        timestamp: Date.now()\n                    }\n                    sendWebsocketMessage(message);\n                }\n                // check for queued messages\n                if (messageQueue.current?.length > 0) {\n                    sendQueuedMessages();\n                }\n            });\n\n            ws.current.addEventListener('message', (event) => {\n                debugLogger(\"Websocket: received message over websocket\", event.data);\n            });\n \n            ws.current.addEventListener('close', (_event) => {\n                debugLogger('WebSocket: connection closed');\n                setConnectionOpen(false);\n                if (autoReconnect && (reconnectAttempts.current < maxReconnectAttempts)) {\n                    reconnectAttempts.current++;\n                    debugLogger(\"Websocket: attempting to reconnect...\", reconnectAttempts);\n                    setTimeout(initializeWebsocket, autoReconnectTimeout);\n                }\n                else {\n                    console.error(\"Websocket: failed to establish connection with server. Please check that your server is configured to receive websocket connections.\");\n                }\n            });\n\n            ws.current.addEventListener('error', (error) => {\n                debugLogger('WebSocket: error', error);\n            });\n        }\n        initializeWebsocket();\n\n        return () => {\n            if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n                ws.current.close();\n            }\n        };\n    }, []);\n\n    const debugLogger = (...args: any[]) => {\n        if (!debug) {\n            return;\n        }\n        console.log(...args);\n    }\n\n    /* handles sending a chat message over websocket */\n    const sendMessage = (msg: WebsocketMessage) => {\n        if (!msg.timestamp) {\n            msg.timestamp = Date.now();\n        }\n        sendWebsocketMessage(msg);\n    };\n\n    const sendWebsocketMessage = (msg: WebsocketMessage) => {\n        if (!ws.current || ws.current.readyState !== WebSocket.OPEN) {\n            console.warn(\"Websocket: connection isn't open - Message queued to send later.\");\n            enqueueMessage(msg);\n            return;\n        }\n        ws.current.send(JSON.stringify(msg));\n        debugLogger(\"Websocket: sent message\", msg);\n        return;\n    }\n\n    const enqueueMessage = (msg: WebsocketMessage) => {\n        if (!messageQueue.current) {\n            messageQueue.current = [];\n        }\n        messageQueue.current.push(msg);\n    }\n\n    const sendQueuedMessages = () => {\n        if (!messageQueue.current || !ws.current || ws.current.readyState !== WebSocket.OPEN) {\n            return;\n        }\n        debugLogger(\"Websocket: dequeuing messages to resend...\");\n        const messages = [...messageQueue.current];\n        messageQueue.current = [];\n        for (const msg of messages) {\n            sendWebsocketMessage(msg);\n        }\n    }\n\n    /**\n     * function for subscribing and setting the callback behavior for when messages are received over websocket. returns the unsubscribe function, for cleanup.\n     * @param callback a callback function for handling when messages are received over websocket. probably for updating state in the consuming component.\n     * @param typeFilters optional param to filter which type of message to listen for - if any messages dont match the types in this array, they will be ignored by this listener.\n     * @returns an unsubscribe function to stop listening for messages; call this function when the component unmounts to prevent memory leaks.\n     */\n    const handleMessage = (callback: (incomingMessage: WebsocketMessage) => void, typeFilters?: string[]) => {\n        const listener = (event: MessageEvent) => {\n            const receivedMessage = JSON.parse(event.data);\n            debugLogger(\"Websocket: incoming message to your listener\", receivedMessage);\n            if (typeFilters && !typeFilters.includes(receivedMessage.type)) {\n                return;\n            }\n            debugLogger('Sending this message to your registered callback.');\n            callback(receivedMessage as WebsocketMessage);\n        };\n\n        if (!ws.current) {\n            console.warn(\"Websocket: failed to add message listener due to websocket being unavailable.\");\n        }\n        else {\n            ws.current.addEventListener('message', listener);\n            let logMessage = \"Websocket: listening for messages\";\n            if (typeFilters) logMessage += ` of the following types: ${typeFilters}`;\n            debugLogger(logMessage);\n        }\n    \n        // Return a cleanup function to unsubscribe when needed\n        return () => {\n            ws.current?.removeEventListener('message', listener);\n        };\n    };\n\n    const contextValue: WebSocketContextType = {\n        sendMessage,\n        handleMessage,\n        connectionOpen\n    };\n\n    return (\n        <WebSocketContext.Provider value={contextValue}>\n            { children } \n        </WebSocketContext.Provider>\n    );\n}\n\nexport const useWebSocket = () => {\n    const context = useContext(WebSocketContext);\n    if (!context) {\n        throw new Error('useWebSocket must be used within a WebSocketProvider');\n    }\n    return context;\n};"],"names":["WebSocketContext","createContext","undefined","WebSocketProvider","_ref","children","authToken","debug","serverURL","_ref$autoReconnect","autoReconnect","_ref$maxReconnectAtte","maxReconnectAttempts","_ref$autoReconnectTim","autoReconnectTimeout","ws","useRef","_useState","useState","connectionOpen","setConnectionOpen","reconnectAttempts","messageQueue","useEffect","initializeWebsocket","current","WebSocket","addEventListener","_event","debugLogger","message","type","content","timestamp","Date","now","sendWebsocketMessage","_messageQueue$current","length","sendQueuedMessages","event","data","setTimeout","console","error","readyState","OPEN","close","_console","log","apply","arguments","sendMessage","msg","warn","enqueueMessage","send","JSON","stringify","push","messages","concat","_iterator","_createForOfIteratorHelperLoose","_step","done","value","handleMessage","callback","typeFilters","listener","receivedMessage","parse","includes","logMessage","_ws$current","removeEventListener","contextValue","React","Provider","useWebSocket","context","useContext","Error"],"mappings":"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"}